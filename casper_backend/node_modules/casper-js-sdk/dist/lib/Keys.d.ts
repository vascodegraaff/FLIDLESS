/**
 * Used to represent account keypairs
 * @packageDocumentation
 */
/// <reference types="node" />
import { SignKeyPair } from 'tweetnacl-ts';
import { CLPublicKey } from './CLValue';
import { CasperHDKey } from './CasperHDKey';
/**
 * Supported Asymmetric Key algorithms
 * @enum
 */
export declare enum SignatureAlgorithm {
    Ed25519 = "ed25519",
    Secp256K1 = "secp256k1"
}
export declare const getKeysFromHexPrivKey: (key: string, variant: SignatureAlgorithm) => AsymmetricKey;
/**
 * Reads in a base64 private key, ignoring the header: `-----BEGIN PUBLIC KEY-----`
 * and footer: `-----END PUBLIC KEY-----`
 * @param {string} content A .pem private key string with a header and footer
 * @returns A base64 private key as a `Uint8Array`
 * @remarks
 * If the provided base64 `content` string does not include a header/footer,
 * it will pass through this function unaffected
 * @example
 * Example PEM:
 *
 * ```
 * -----BEGIN PUBLIC KEY-----\r\n
 * MFYwEAYHKoZIzj0CAQYFK4EEAAoDQgAEj1fgdbpNbt06EY/8C+wbBXq6VvG+vCVD\r\n
 * Nl74LvVAmXfpdzCWFKbdrnIlX3EFDxkd9qpk35F/kLcqV3rDn/u3dg==\r\n
 * -----END PUBLIC KEY-----\r\n
 * ```
 */
export declare function readBase64WithPEM(content: string): Uint8Array;
export declare const validateSignature: (msg: Uint8Array, signature: Uint8Array, pk: CLPublicKey) => boolean;
/** Public/private keypair object for representing an account */
export declare abstract class AsymmetricKey {
    readonly publicKey: CLPublicKey;
    readonly privateKey: Uint8Array;
    readonly signatureAlgorithm: SignatureAlgorithm;
    /**
     * Constructs an `AsymmetricKey` inherited object
     * @param {Uint8Array} publicKey An account's public key as a byte array
     * @param {Uint8Array} privateKey An account's private key as a byte array
     * @param {SignatureAlgorithm} signatureAlgorithm The signature algorithm of the key. Currently supported are Ed25519 and Secp256k1
     */
    constructor(publicKey: Uint8Array, privateKey: Uint8Array, signatureAlgorithm: SignatureAlgorithm);
    /**
     * Computes the blake2b account hash of the public key
     * @returns The account hash as a byte array
     */
    accountHash(): Uint8Array;
    /**
     * Gets the hexadecimal public key of the account
     * @returns The public key of the `AsymmetricKey` as a hexadecimal string
     */
    accountHex(): string;
    /**
     * Inserts the provided `content` and `tag` into a .pem compliant string
     * @param tag The tag inserted on the END line
     * @param content The base-64 PEM compliant private key
     */
    protected toPem(tag: string, content: string): string;
    /**
     * Export the public key encoded as a .pem
     */
    abstract exportPublicKeyInPem(): string;
    /**
     * Export the private key encoded as a .pem
     */
    abstract exportPrivateKeyInPem(): string;
    /**
     * Sign a message using this `AsymmetricKey`'s private key
     * @param {Uint8Array} msg The message to be signed, as a byte array
     * @returns A byte array containing the signed message
     */
    abstract sign(msg: Uint8Array): Uint8Array;
    /**
     * Validate the signature by comparing it to the provided message
     * @param {Uint8Array} signature The signature as a byte array
     * @param {Uint8Array} msg The original message to be validated
     * @returns `true` if the signature is valid, `false` otherwise
     */
    abstract verify(signature: Uint8Array, msg: Uint8Array): boolean;
}
/**
 * Ed25519 variant of `AsymmetricKey`
 * @remarks
 * Based on SignatureAlgorithm.scala
 */
export declare class Ed25519 extends AsymmetricKey {
    /**
     * Constructs a new Ed25519 object from a `SignKeyPair`
     * @param {SignKeyPair} keyPair An object containing the keys "publicKey" and "secretKey" with corresponding `ByteArray` values
     * @see [SignKeyPair](https://www.npmjs.com/package/tweetnacl-ts#sign_keypair)
     */
    constructor(keyPair: SignKeyPair);
    /**
     * Generates a new Ed25519 key pair
     */
    static new(): Ed25519;
    /**
     * Generate the accountHex for the Ed25519 public key
     * @param publicKey
     */
    static accountHex(publicKey: Uint8Array): string;
    /**
     * Parse the key pair from a public key file and the corresponding private key file
     * @param {string} publicKeyPath Path of public key file
     * @param {string} privateKeyPath Path of private key file
     * @returns A new `AsymmetricKey`
     */
    static parseKeyFiles(publicKeyPath: string, privateKeyPath: string): AsymmetricKey;
    /**
     * Generates the account hash of a Ed25519 public key
     * @param {Uint8Array} publicKey An Ed25519 public key
     * @returns The blake2b account hash of the public key
     */
    static accountHash(publicKey: Uint8Array): Uint8Array;
    /**
     * Construct a keypair from a public key and corresponding private key
     * @param {Uint8Array} publicKey The public key of an Ed25519 account
     * @param {Uint8Array} privateKey The private key of the same Ed25519 account
     * @returns A new `AsymmetricKey` keypair
     */
    static parseKeyPair(publicKey: Uint8Array, privateKey: Uint8Array): AsymmetricKey;
    /**
     * Parses a file containing an Ed25519 private key
     * @param {string} path The path to the private key file
     * @returns A `Uint8Array` typed representation of the private key
     * @see {@link Ed25519.parsePrivateKey}
     */
    static parsePrivateKeyFile(path: string): Uint8Array;
    /**
     * Parses a file containing an Ed25519 public key
     * @param {string} path The path to the public key file
     * @returns A `Uint8Array` typed representation of the public key
     * @see {@link Ed25519.parsePublicKey}
     */
    static parsePublicKeyFile(path: string): Uint8Array;
    /**
     * Parses a byte array containing an Ed25519 private key
     * @param {Uint8Array} bytes A private key in bytes
     * @returns A validated byte array containing the provided Ed25519 private key
     * @see {@link Ed25519.parseKey}
     */
    static parsePrivateKey(bytes: Uint8Array): Uint8Array | Buffer;
    /**
     * Parses a byte array containing an Ed25519 public key
     * @param {Uint8Array} bytes A public key in bytes
     * @returns A validated byte array containing the provided Ed25519 public key
     * @see {@link Ed25519.parseKey}
     */
    static parsePublicKey(bytes: Uint8Array): Uint8Array | Buffer;
    /**
     * Calls global {@link readBase64WithPEM} and returns the result
     * @param {string} content A .pem private key string with a header and footer
     * @returns The result of global `readBase64WithPEM`
     * @see {@link readBase64WithPEM}
     */
    static readBase64WithPEM(content: string): Uint8Array;
    /**
     * Read the Base64 content of a file, ignoring PEM frames
     * @param {string} path The path to the PEM file
     * @returns The result of {@link Ed25519.readBase64WithPEM} after reading in the content as a `string` with `fs`
     */
    private static readBase64File;
    /**
     * Parses and validates a key in a certain range "from" to "to"
     * @param {Uint8Array} bytes The key to be parsed and validated
     * @param {number} from The starting index from which to parse the key
     * @param {number} to The ending index from which to parse the key
     * @returns The parsed key
     * @throws `Error` if the key is of an unexpected length
     */
    private static parseKey;
    /**
     * Convert this instance's private key to PEM format
     * @returns A PEM compliant string containing this instance's private key
     * @see {@link AsymmetricKey.toPem}
     */
    exportPrivateKeyInPem(): string;
    /**
     * Convert this instance's public key to PEM format
     * @returns A PEM compliant string containing this instance's public key
     * @see {@link AsymmetricKey.toPem}
     */
    exportPublicKeyInPem(): string;
    /**
     * Sign a message by using this instance's keypair
     * @param {Uint8Array} msg The message to be signed, as a byte array
     * @returns `Uint8Array` typed signature of the provided `msg`
     * @see [sign_detached](https://www.npmjs.com/package/tweetnacl-ts#sign_detachedmessage-secretkey)
     */
    sign(msg: Uint8Array): Uint8Array;
    /**
     * Verify the signature along with the raw message
     * @param signature
     * @param msg
     */
    verify(signature: Uint8Array, msg: Uint8Array): boolean;
    /**
     * Derive public key from private key
     * @param privateKey
     */
    static privateToPublicKey(privateKey: Uint8Array): Uint8Array;
    /**
     * Restore Ed25519 keyPair from private key file
     * @param privateKeyPath
     */
    static loadKeyPairFromPrivateFile(privateKeyPath: string): AsymmetricKey;
}
export declare class Secp256K1 extends AsymmetricKey {
    constructor(publicKey: Uint8Array, privateKey: Uint8Array);
    /**
     * Generating a new Secp256K1 key pair
     */
    static new(): Secp256K1;
    /**
     * Parse the key pair from publicKey file and privateKey file
     * @param publicKeyPath path of public key file
     * @param privateKeyPath path of private key file
     */
    static parseKeyFiles(publicKeyPath: string, privateKeyPath: string): AsymmetricKey;
    /**
     * Generate the accountHash for the Secp256K1 public key
     * @param publicKey
     */
    static accountHash(publicKey: Uint8Array): Uint8Array;
    /**
     * Generate the accountHex for the Secp256K1 public key
     * @param publicKey
     */
    static accountHex(publicKey: Uint8Array): string;
    /**
     * Construct keyPair from public key and private key
     * @param publicKey
     * @param privateKey
     * @param originalFormat the format of the public/private key
     */
    static parseKeyPair(publicKey: Uint8Array, privateKey: Uint8Array, originalFormat: 'raw' | 'der'): AsymmetricKey;
    static parsePrivateKeyFile(path: string): Uint8Array;
    static parsePublicKeyFile(path: string): Uint8Array;
    static parsePrivateKey(bytes: Uint8Array, originalFormat?: 'der' | 'raw'): Buffer;
    static parsePublicKey(bytes: Uint8Array, originalFormat?: 'der' | 'raw'): Uint8Array;
    static readBase64WithPEM(content: string): Uint8Array;
    /**
     * Read the Base64 content of a file, get rid of PEM frames.
     *
     * @param path the path of file to read from
     */
    private static readBase64File;
    /**
     * Export the private key encoded in pem
     */
    exportPrivateKeyInPem(): string;
    /**
     * Expect the public key encoded in pem
     */
    exportPublicKeyInPem(): string;
    /**
     * Sign the message by using the keyPair
     * @param msg
     */
    sign(msg: Uint8Array): Uint8Array;
    /**
     * Verify the signature along with the raw message
     * @param signature
     * @param msg
     */
    verify(signature: Uint8Array, msg: Uint8Array): boolean;
    /**
     * Derive public key from private key
     * @param privateKey
     */
    static privateToPublicKey(privateKey: Uint8Array): Uint8Array;
    /**
     * Restore Secp256K1 keyPair from private key file
     * @param privateKeyPath a path to file of the private key
     */
    static loadKeyPairFromPrivateFile(privateKeyPath: string): AsymmetricKey;
    /**
     * From hdKey derive a child Secp256K1 key
     * @param hdKey
     * @param index
     */
    static deriveIndex(hdKey: CasperHDKey, index: number): Secp256K1;
}
