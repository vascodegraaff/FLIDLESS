/**
 * Util methods for making Deploy message
 *
 * @packageDocumentation
 */
import { Result } from 'ts-results';
import { CLValue, CLPublicKey, ToBytes, CLURef, ToBytesResult } from './CLValue';
import { RuntimeArgs } from './RuntimeArgs';
import { DeployUtil } from './index';
import { AsymmetricKey } from './Keys';
import { BigNumber, BigNumberish } from '@ethersproject/bignumber';
/**
 * Returns a humanizer duration
 * @param ttl in milliseconds
 * @returns A human-readable time in days, hours, minutes, seconds, then milliseconds
 */
export declare const humanizerTTL: (ttl: number) => string;
/**
 * Returns duration in milliseconds
 * @param ttl Human-readable string generated by [humanizerTTL](#L91)
 * @returns The time-to-live in milliseconds
 */
export declare const dehumanizerTTL: (ttl: string) => number;
/**
 * An object containing a unique address constructed from the `transferId` of a `Deploy`
 */
export declare class UniqAddress {
    /** The `CLPublicKey` representation of the transacting account */
    publicKey: CLPublicKey;
    /** A transaction nonce */
    transferId: BigNumber;
    /**
     * Constructs UniqAddress from the transacting account's `CLPublicKey` and unique transferId.
     * @param publicKey CLPublicKey instance
     * @param transferId BigNumberish value (can be also string representing number). Max U64.
     */
    constructor(publicKey: CLPublicKey, transferId: BigNumberish);
    /**
     * Stringifies the `UniqAddress`
     * @returns string with the format "accountHex-transferIdHex"
     */
    toString(): string;
    /**
     * Builds UniqAddress from string
     * @param value `UniqAddress` string representation in the format "accountHex-transferIdHex"
     * @returns A new `UniqAddress`
     */
    static fromString(value: string): UniqAddress;
}
/** Header data of a `Deploy` object that contains information like the transacting account, timestamp, gas price, and other relevent deploy information */
export declare class DeployHeader implements ToBytes {
    account: CLPublicKey;
    timestamp: number;
    ttl: number;
    gasPrice: number;
    bodyHash: Uint8Array;
    dependencies: Uint8Array[];
    chainName: string;
    /**
     * Constructs the header portion of a deploy
     * @param account The `CLPublicKey` representation of the transacting account.
     * @param timestamp The UNIX timestamp at which the deploy was created
     * @param ttl The amount of time in milliseconds that the deploy is given to live before it is dropped and rejected by validators
     * @param gasPrice Price per gas unit for this deploy, measured in motes, where 1 mote = 10^-9 CSPR
     * @param bodyHash  Hash of the compiled WebAssembly logic
     * @param dependencies Zero, one, or many instances of session code that is/are required to execute before this deploy
     * @param chainName The chain for which the deploy should be deployed on. For the Casper mainnet, use "casper" and for the testnet, use "casper-test"
     */
    constructor(account: CLPublicKey, timestamp: number, ttl: number, gasPrice: number, bodyHash: Uint8Array, dependencies: Uint8Array[], chainName: string);
    /**
     * Converts `DeployHeader` to `ToBytesResult`.
     * @returns `Ok` result, consisting of the account's byte representation, the timestamp, ttl, gasPrice, bodyHash, dependencies, and chainName concatenated together in a byte array
     */
    toBytes(): ToBytesResult;
}
export interface DeployJson {
    session: Record<string, any>;
    approvals: {
        signature: string;
        signer: string;
    }[];
    header: DeployHeader;
    payment: Record<string, any>;
    hash: string;
}
/**
 * A struct containing a signature and the public key of the signer.
 */
export declare class Approval {
    signer: string;
    signature: string;
}
declare abstract class ExecutableDeployItemInternal implements ToBytes {
    abstract tag: number;
    abstract args: RuntimeArgs;
    abstract toBytes(): ToBytesResult;
    getArgByName(name: string): CLValue | undefined;
    setArg(name: string, value: CLValue): void;
}
/**
 * An object which can be passed along in a deploy, including session code and runtime arguments.
 */
export declare class ModuleBytes extends ExecutableDeployItemInternal {
    tag: number;
    /**
     * A `Uint8Array` typed representation of the session code.
     */
    moduleBytes: Uint8Array;
    /**
     * A `RuntimeArgs` object containing the runtime arguments passed along with the deploy.
     */
    args: RuntimeArgs;
    /**
     * Constructs a `ModuleBytes` object from the `Uint8Array` typed session code and a `RuntimeArgs` object.
     * @param moduleBytes The `Uint8Array` representation of the session code
     * @param args Runtime arguments as `RuntimeArgs`
     */
    constructor(moduleBytes: Uint8Array, args: RuntimeArgs);
    /**
     * Converts `ModuleBytes` to `ToBytesResult`
     * @returns `Ok` result, consisting of the `ModuleBytes` as a byte array
     */
    toBytes(): ToBytesResult;
}
/** The `StoredContractByHash` class, when instantiated, represents a stored smart contract referenced by it's hash */
export declare class StoredContractByHash extends ExecutableDeployItemInternal {
    /** An identifier that other functions use to recognize that `StoredContractByHash` objects are indeed stored contracts by hash during deserialization */
    tag: number;
    /** The `Uint8Array` typed hash of the stored smart contract */
    hash: Uint8Array;
    /** An entrypoint of the stored smart contract */
    entryPoint: string;
    /** A `RuntimeArgs` object containing the runtime arguments to be passed along with the deploy. */
    args: RuntimeArgs;
    /**
     * Constructs a `StoredContractByHash` object from the `Uint8Array` typed hash, entrypoint of the contract, and associated runtime arguments
     * @param hash `Uint8Array` typed smart contract hash
     * @param entryPoint An entrypoint of the smart contract
     * @param args The runtime arguments for interaction on the `entryPoint`
     */
    constructor(hash: Uint8Array, entryPoint: string, args: RuntimeArgs);
    /**
     * Converts `StoredContractByHash` to `ToBytesResult`
     * @returns `Ok` result, consisting of the tag, contract hash, entrypoint, and runtime arguments as a byte array
     */
    toBytes(): ToBytesResult;
}
/** The `StoredContractByName` class, when instantiated, represents a stored smart contract referenced by it's name */
export declare class StoredContractByName extends ExecutableDeployItemInternal {
    /** An identifier that other functions use to recognize that `StoredContractByName` objects are indeed stored contracts by name during deserialization */
    tag: number;
    /** The name of the smart contract */
    name: string;
    /** An entrypoint of the smart contract */
    entryPoint: string;
    /** A `RuntimeArgs` object containing the runtime arguments to be passed along with the deploy. */
    args: RuntimeArgs;
    /**
     * Constructs a `StoredContractByName` object from the name, entrypoint of the contract, and associated runtime arguments
     * @param name The name of the smart contract
     * @param entryPoint An entrypoint of the smart contract
     * @param args The runtime arguments for interaction on the `entryPoint`
     */
    constructor(name: string, entryPoint: string, args: RuntimeArgs);
    /**
     * Converts `StoredContractByName` to `ToBytesResult`
     * @returns `Ok` result, consisting of the tag, name, entrypoint, and runtime arguments as a byte array
     */
    toBytes(): ToBytesResult;
}
/** The `StoredVersionedContractByName` class, when instantiated, represents a stored smart contract referenced by it's name */
export declare class StoredVersionedContractByName extends ExecutableDeployItemInternal {
    /** An identifier that other functions use to recognize that `StoredVersionedContractByName` objects are indeed stored versioned contracts by name during deserialization */
    tag: number;
    /** The name of the stored versioned contract */
    name: string;
    /** The version of the contract */
    version: number | null;
    /** An entrypoint of the smart contract */
    entryPoint: string;
    /** A `RuntimeArgs` object containing the runtime arguments to be passed along with the deploy. */
    args: RuntimeArgs;
    /**
     * Constructs a `StoredContractByName` object from the name, entrypoint of the contract, and associated runtime arguments
     * @param name The name of the smart contract
     * @param version The version of the named smart contract
     * @param entryPoint An entrypoint of the smart contract
     * @param args The runtime arguments for interaction on the `entryPoint`
     */
    constructor(name: string, version: number | null, entryPoint: string, args: RuntimeArgs);
    /**
     * Converts `StoredVersionedContractByName` to `ToBytesResult`
     * @returns `Ok` result, consisting of the tag, name, serialized version, entrypoint, and runtime arguments as a byte array
     */
    toBytes(): ToBytesResult;
}
/** The `StoredVersionedContractByHash` class, when instantiated, represents a stored versioned smart contract referenced by it's hash */
export declare class StoredVersionedContractByHash extends ExecutableDeployItemInternal {
    /** An identifier that other functions use to recognize that `StoredVersionedContractByHash` objects are indeed stored versioned contracts by hash during deserialization */
    tag: number;
    /** The `Uint8Array` typed hash of the stored smart contract */
    hash: Uint8Array;
    /** The version of the contract */
    version: number | null;
    /** An entrypoint of the stored smart contract */
    entryPoint: string;
    /** A `RuntimeArgs` object containing the runtime arguments to be passed along with the deploy. */
    args: RuntimeArgs;
    /**
     * Constructs a `StoredContractByHash` object from the `Uint8Array` typed hash, entrypoint of the contract, and associated runtime arguments
     * @param hash `Uint8Array` typed smart contract hash
     * @param version The version of the smart contract
     * @param entryPoint An entrypoint of the smart contract
     * @param args The runtime arguments for interaction on the `entryPoint`
     */
    constructor(hash: Uint8Array, version: number | null, entryPoint: string, args: RuntimeArgs);
    /**
     * Converts `StoredVersionedContractByHash` to `ToBytesResult`
     * @returns `Ok` result, consisting of the tag, hash, serialized version, entrypoint, and runtime arguments as a byte array
     */
    toBytes(): ToBytesResult;
}
/** Represents a transferral deploy. Construct and deploy to execute a standard CSPR transfer */
export declare class Transfer extends ExecutableDeployItemInternal {
    /** An identifier that other functions use to recognize that `Transfer` objects are indeed transfers during deserialization */
    tag: number;
    /** Runtime arguments necessary for building the transfer deploy */
    args: RuntimeArgs;
    /**
     * Constructor for Transfer deploy item.
     * @param args `RuntimeArgs` containing the transfer amount in motes, the URef of the target purse or the public key of the target account, the URef of the source purse, and the transfer id
     * @remarks The `RuntimeArgs` should contain the arguments `amount`, `target`, `sourcePurse`, and `id`
     */
    constructor(args: RuntimeArgs);
    /**
     * Converts `Transfer` to `ToBytesResult`
     * @returns `Ok` result, consisting of the tag and runtime arguments concatenated in a byte array
     */
    toBytes(): ToBytesResult;
}
/** Represents an executable deploy object that can be deployed on-chain. `ModuleBytes`, `StoredContractByHash`, `StoredContractByName`, `StoredVersionedContractByHash`, `StoredVersionedContractByName`, and `Transfer` objects can all be casted as `ExecutableDeployItem`s. */
export declare class ExecutableDeployItem implements ToBytes {
    /** Optional `ModuleBytes` object representing the `ExecutableDeployItem` if applicable. */
    moduleBytes?: ModuleBytes;
    /** Optional `StoredContractByHash` object representing the `ExecutableDeployItem` if applicable. */
    storedContractByHash?: StoredContractByHash;
    /** Optional `StoredContractByName` object representing the `ExecutableDeployItem` if applicable. */
    storedContractByName?: StoredContractByName;
    /** Optional `StoredVersionedContractByHash` object representing the `ExecutableDeployItem` if applicable. */
    storedVersionedContractByHash?: StoredVersionedContractByHash;
    /** Optional `StoredVersionedContractByName` object representing the `ExecutableDeployItem` if applicable. */
    storedVersionedContractByName?: StoredVersionedContractByName;
    /** Optional `Transfer` object representing the `ExecutableDeployItem` if applicable. */
    transfer?: Transfer;
    /**
     * Converts `ExecutableDeployItem` to `ToBytesResult` depending on the `ExecutableDeployItem`'s type. Throws an error if it cannot serialize the `ExecutableDeployItem` from its parent type.
     * @returns `ModuleBytes`, or `StoredContractByHash`, or `StoredContractByName`, or `StoredVersionedContractByHash`, or `StoredVersionedContractByName`, or `Transfer` depending on the original type.
     */
    toBytes(): ToBytesResult;
    /**
     * Gets a `CLValue` argument via its name, returns `undefined` if the argument does not exist. Throws an error if it cannot serialize the `ExecutableDeployItem` from its original type.
     * @param name The name of the argument
     * @returns A `CLValue` runtime argument
     */
    getArgByName(name: string): CLValue | undefined;
    /**
     * Sets an argument given an argument name and a value typed as a `CLValue`. Throws an error if it cannot serialize the `ExecutableDeployItem` from its original type.
     * @param name The name of the argument being set
     * @param value The `CLValue` that will be stored under the new argument `name`
     * @returns The success status of setting the argument
     */
    setArg(name: string, value: CLValue): void;
    /**
     * Builds an `ExecutableDeployItem` from an `ExecutableDeployItemInternal`. The `ExecutableDeployItemInternal` abstract class is inherited by `ModuleBytes`, `StoredContractByHash`, `StoredContractByName`, `StoredVersionedContractByHash`, `StoredVersionedContractByName`, and `Transfer`, so you may pass in an object of any of these types.
     * @param item The `ExecutableDeployItemInternal` to build into an `ExecutableDeployItem`
     */
    static fromExecutableDeployItemInternal(item: ExecutableDeployItemInternal): DeployUtil.ExecutableDeployItem;
    /**
     * Creates a new `ModuleBytes` object from a `Uint8Array` of module bytes and a set of `RuntimeArgs`
     * @param moduleBytes A set of module bytes as a `Uint8Array`
     * @param args The runtime arguments for the new `ModuleBytes` object
     * @returns A new `ExecutableDeployItem` created from a new `ModuleBytes` object built using `moduleBytes` and `args`
     */
    static newModuleBytes(moduleBytes: Uint8Array, args: RuntimeArgs): ExecutableDeployItem;
    /**
     * Creates a new `StoredContractByHash` object from a `Uint8Array` contract hash, entrypoint, and runtime arguments
     * @param hash `Uint8Array` representation of a smart contract hash
     * @param entryPoint Name of an entrypoint of the stored contract
     * @param args The runtime arguments for the new `StoredContractByHash` object
     * @returns A new `ExecutableDeployItem` created from a new `StoredContractByHash` object built using `hash`, `entryPoint` and `args`
     */
    static newStoredContractByHash(hash: Uint8Array, entryPoint: string, args: RuntimeArgs): DeployUtil.ExecutableDeployItem;
    /**
     * Creates a new `StoredContractByName` object from a contract name, entrypoint, and runtime arguments
     * @param name The name of the stored smart contract
     * @param entryPoint Name of an entrypoint of the stored contract
     * @param args The runtime arguments for the new `StoredContractByHash` object
     * @returns A new `ExecutableDeployItem` created from a new `StoredContractByName` object built using `name`, `entryPoint` and `args`
     */
    static newStoredContractByName(name: string, entryPoint: string, args: RuntimeArgs): DeployUtil.ExecutableDeployItem;
    /**
     * Creates a new `StoredVersionedContractByHash` object from a `Uint8Array` contract hash, version number, entrypoint, and runtime arguments
     * @param hash `Uint8Array` representation of a smart contract hash
     * @param version The version of the stored contract
     * @param entryPoint Name of an entrypoint of the stored contract
     * @param args The runtime arguments for the new `StoredContractByHash` object
     * @returns A new `ExecutableDeployItem` created from a new `StoredVersionedContractByHash` object built using `hash`, `version`, `entryPoint` and `args`
     */
    static newStoredVersionContractByHash(hash: Uint8Array, version: number | null, entryPoint: string, args: RuntimeArgs): DeployUtil.ExecutableDeployItem;
    /**
     * Creates a new `StoredVersionedContractByName` object from a contract name, version number, entrypoint, and runtime arguments
     * @param name The name of the stored smart contract
     * @param version The version of the stored contract
     * @param entryPoint Name of an entrypoint of the stored contract
     * @param args The runtime arguments for the new `StoredContractByHash` object
     * @returns A new `ExecutableDeployItem` created from a new `StoredVersionedContractByName` object built using `name`, `version`, `entryPoint` and `args`
     */
    static newStoredVersionContractByName(name: string, version: number | null, entryPoint: string, args: RuntimeArgs): DeployUtil.ExecutableDeployItem;
    /**
     * Creates a new `Transfer` object
     * @param amount The number of motes to transfer, where 1 mote = 1 * 10^-9 CSPR
     * @param target URef of the target purse or the public key of target account, as a `CLUref` or `CLPublicKey` respectively
     * @param sourcePurse URef of the source purse. If this is omitted, the main purse of the account creating this transfer will be used as the source purse
     * @param id User-defined transfer id
     * @returns New `Transfer` object which can be deployed to execute a standard CSPR transferral
     */
    static newTransfer(amount: BigNumberish, target: CLURef | CLPublicKey, sourcePurse: CLURef | null | undefined, id: BigNumberish): ExecutableDeployItem;
    /**
     * Creates a new `Transfer` object with an optional transfer id
     * @param amount The number of motes to transfer, where 1 mote = 1 * 10^-9 CSPR
     * @param target URef of the target purse or the public key of target account, as a `CLUref` or `CLPublicKey` respectively
     * @param sourcePurse URef of the source purse. If this is omitted, the main purse of the account creating this transfer will be used as the source purse
     * @param id User-defined transfer id, which if not provided will be created on the fly
     * @returns New `Transfer` object which can be deployed to execute a standard CSPR transferral
     */
    static newTransferWithOptionalTransferId(amount: BigNumberish, target: CLURef | CLPublicKey, sourcePurse?: CLURef | null, id?: BigNumberish): DeployUtil.ExecutableDeployItem;
    /**
     * Constructor for Transfer deploy item using UniqAddress.
     * @param source `CLPublicKey` of source account
     * @param target `UniqAddress` of target account
     * @param amount The amount of motes to transfer, where 1 mote = 1 * 10^-9 CSPR
     * @param paymentAmount The number of motes paid to execution engine, where 1 mote = 1 * 10^-9 CSPR
     * @param chainName Name of the chain, to avoid the `Deploy` from being accidentally or maliciously included in a different chain.
     * @param gasPrice The gas price at which to execute the deploy
     * @param ttl Time that the `Deploy` will remain valid for, in milliseconds. The default value is 1800000, which is 30 minutes
     * @param sourcePurse URef of the source purse. If this is omitted, the main purse of the account creating this \
     * transfer will be used as the source purse
     * @returns A new `Deploy` representing a transferral to a unique address
     */
    static newTransferToUniqAddress(source: CLPublicKey, target: UniqAddress, amount: BigNumberish, paymentAmount: BigNumberish, chainName: string, gasPrice?: number, ttl?: number, sourcePurse?: CLURef): Deploy;
    /**
     * Identifies whether the `ExecutableDeployItem` is of the original type `ModuleBytes`
     * @returns `true` is the `ExecutableDeployItem` conforms to `ModuleBytes`, and `false` otherwise.
     */
    isModuleBytes(): boolean;
    /**
     * Casts the `ExecutableDeployItem` to `ModuleBytes` if possible
     * @returns `ModuleBytes` representation of `ExecutableDeployItem`, or `undefined` if the `ExecutableDeployItem` cannot be cast
     */
    asModuleBytes(): ModuleBytes | undefined;
    /**
     * Identifies whether the `ExecutableDeployItem` is of the original type `StoredContractByHash`
     * @returns `true` is the `ExecutableDeployItem` conforms to `StoredContractByHash`, and `false` otherwise.
     */
    isStoredContractByHash(): boolean;
    /**
     * Casts the `ExecutableDeployItem` to `StoredContractByHash` if possible
     * @returns `StoredContractByHash` representation of `ExecutableDeployItem`, or `undefined` if the `ExecutableDeployItem` cannot be cast
     */
    asStoredContractByHash(): StoredContractByHash | undefined;
    /**
     * Identifies whether the `ExecutableDeployItem` is of the original type `StoredContractByName`
     * @returns `true` is the `ExecutableDeployItem` conforms to `StoredContractByName`, and `false` otherwise.
     */
    isStoredContractByName(): boolean;
    /**
     * Casts the `ExecutableDeployItem` to `StoredContractByName` if possible
     * @returns `StoredContractByName` representation of `ExecutableDeployItem`, or `undefined` if the `ExecutableDeployItem` cannot be cast
     */
    asStoredContractByName(): StoredContractByName | undefined;
    /**
     * Identifies whether the `ExecutableDeployItem` is of the original type `StoredVersionedContractByName`
     * @returns `true` is the `ExecutableDeployItem` conforms to `StoredVersionedContractByName`, and `false` otherwise.
     */
    isStoredVersionContractByName(): boolean;
    /**
     * Casts the `ExecutableDeployItem` to `StoredVersionedContractByName` if possible
     * @returns `StoredVersionedContractByName` representation of `ExecutableDeployItem`, or `undefined` if the `ExecutableDeployItem` cannot be cast
     */
    asStoredVersionContractByName(): StoredVersionedContractByName | undefined;
    /**
     * Identifies whether the `ExecutableDeployItem` is of the original type `StoredVersionedContractByHash`
     * @returns `true` is the `ExecutableDeployItem` conforms to `StoredVersionedContractByHash`, and `false` otherwise.
     */
    isStoredVersionContractByHash(): boolean;
    /**
     * Casts the `ExecutableDeployItem` to `StoredVersionedContractByHash` if possible
     * @returns `StoredVersionedContractByHash` representation of `ExecutableDeployItem`, or `undefined` if the `ExecutableDeployItem` cannot be cast
     */
    asStoredVersionContractByHash(): StoredVersionedContractByHash | undefined;
    /**
     * Identifies whether the `ExecutableDeployItem` is of the original type `Transfer`
     * @returns `true` is the `ExecutableDeployItem` conforms to `Transfer`, and `false` otherwise.
     */
    isTransfer(): boolean;
    /**
     * Casts the `ExecutableDeployItem` to `Transfer` if possible
     * @returns `Transfer` representation of `ExecutableDeployItem`, or `undefined` if the `ExecutableDeployItem` cannot be cast
     */
    asTransfer(): Transfer | undefined;
}
/**
 * A deploy containing a smart contract along with the requester's signature(s).
 */
export declare class Deploy {
    /**
     * The deploy hash
     */
    hash: Uint8Array;
    /**
     * The header of the deploy
     */
    header: DeployHeader;
    /**
     * The payment logic of the deploy
     */
    payment: ExecutableDeployItem;
    /**
     * The session code of the deploy
     */
    session: ExecutableDeployItem;
    /**
     * An array of approvals in the form of signatures from an account or multiple accounts
     */
    approvals: Approval[];
    /**
     * Constructs a `Deploy` object
     * @param hash The DeployHash identifying this Deploy
     * @param header The deploy header
     * @param payment An ExecutableDeployItem representing the payment logic
     * @param session An ExecutableDeployItem representing the session logic
     * @param approvals An array of signatures and associated accounts who have approved this deploy
     */
    constructor(hash: Uint8Array, header: DeployHeader, payment: ExecutableDeployItem, session: ExecutableDeployItem, approvals: Approval[]);
    /**
     * Identifies whether this `Deploy` represents a transfer of CSPR
     * @returns `true` if the `Deploy` is a `Transfer`, and `false` otherwise
     */
    isTransfer(): boolean;
    /**
     * Identifies whether this `Deploy` represents a standard payment, like that of gas payment
     * @returns `true` if the `Deploy` is a standard payment, and `false` otherwise
     */
    isStandardPayment(): boolean;
    /**
     * Can be used to send the `Deploy` to an online Casper node
     * @param nodeUrl The url of a live Casper node
     * @returns The deploy hash of the `Deploy`
     * @remarks Works by instantiating a `CasperClient` with the provided `nodeUrl` and calling [`putDeploy`](./CasperClient.ts#L157) on it
     */
    send(nodeUrl: string): Promise<string>;
    /**
     * Signs the `Deploy` using the provided `AsymmetricKey`(s)
     * @param keys An array consisting of one or many `AsymmetricKey`(s)
     * @returns The original `Deploy` signed by the provided `AsymmetricKey`(s)
     */
    sign(keys: AsymmetricKey[]): Deploy;
}
/**
 * Serializes a `DeployHeader` into an array of bytes
 * @param deployHeader
 * @returns A serialized representation of the provided `DeployHeader`
 */
export declare const serializeHeader: (deployHeader: DeployHeader) => ToBytesResult;
/**
 * Serializes the body of a deploy into an array of bytes
 * @param payment Payment logic for use in a deployment
 * @param session Session logic of a deploy
 * @returns `Uint8Array` typed byte array, containing the payment and session logic of a deploy
 */
export declare const serializeBody: (payment: ExecutableDeployItem, session: ExecutableDeployItem) => Uint8Array;
/**
 * Serializes an array of `Approval`s into a `Uint8Array` typed byte array
 * @param approvals An array of `Approval`s to be serialized
 * @returns `Uint8Array` typed byte array that can be deserialized to an array of `Approval`s
 */
export declare const serializeApprovals: (approvals: Approval[]) => Uint8Array;
/**
 * enum of supported contract types
 * @enum
 */
export declare enum ContractType {
    /** A pure WebAssembly representation of a smart contract */
    WASM = "WASM",
    /** A linked contract by hash */
    Hash = "Hash",
    /** A linked contract by name */
    Name = "Name"
}
/** The parameters of a `Deploy` object */
export declare class DeployParams {
    accountPublicKey: CLPublicKey;
    chainName: string;
    gasPrice: number;
    ttl: number;
    dependencies: Uint8Array[];
    timestamp?: number | undefined;
    /**
     * Container for `Deploy` construction options.
     * @param accountPublicKey The public key of the deploying account as a `CLPublicKey`
     * @param chainName Name of the chain, to avoid the `Deploy` from being accidentally or maliciously included in a different chain.
     * @param gasPrice Conversion rate between the cost of Wasm opcodes and the motes sent by the payment code, where 1 mote = 1 * 10^-9 CSPR
     * @param ttl Time that the `Deploy` will remain valid for, in milliseconds. The default value is 1800000, which is 30 minutes
     * @param dependencies Hex-encoded `Deploy` hashes of deploys which must be executed before this one.
     * @param timestamp  If `timestamp` is empty, the current time will be used. Note that timestamp is UTC, not local.
     */
    constructor(accountPublicKey: CLPublicKey, chainName: string, gasPrice?: number, ttl?: number, dependencies?: Uint8Array[], timestamp?: number | undefined);
}
/**
 * Builds a `Deploy` object from `DeployParams`, session logic, and payment logic
 * @param deployParam The parameters of the deploy, see [DeployParams](#L1323)
 * @param session The session logic of the deploy
 * @param payment The payment logic of the deploy
 * @returns A new `Deploy` object
 */
export declare function makeDeploy(deployParam: DeployParams, session: ExecutableDeployItem, payment: ExecutableDeployItem): Deploy;
/**
 * Uses the provided key pair to sign the Deploy message
 * @param deploy Either an unsigned `Deploy` object or one with other signatures
 * @param signingKey The keypair used to sign the `Deploy`
 */
export declare const signDeploy: (deploy: Deploy, signingKey: AsymmetricKey) => Deploy;
/**
 * Sets the algorithm of the already generated signature
 *
 * @param deploy A `Deploy` to be signed with `sig`
 * @param sig the Ed25519 or Secp256K1 signature
 * @param publicKey the public key used to generate the signature
 */
export declare const setSignature: (deploy: Deploy, sig: Uint8Array, publicKey: CLPublicKey) => Deploy;
/**
 * Creates an instance of standard payment logic
 *
 * @param paymentAmount The amount of motes to be used to pay for gas
 * @returns A standard payment, as an `ExecutableDeployItem` to be attached to a `Deploy`
 */
export declare const standardPayment: (paymentAmount: BigNumberish) => DeployUtil.ExecutableDeployItem;
/**
 * Convert the deploy object to a JSON representation
 *
 * @param deploy The `Deploy` object to convert to JSON
 * @returns A JSON version of the `Deploy`, which can be converted back later
 */
export declare const deployToJson: (deploy: Deploy) => {
    deploy: import("typedjson").JsonTypes;
};
/**
 * Convert a JSON representation of a deploy to a `Deploy` object
 *
 * @param json A JSON representation of a `Deploy`
 * @returns A `Deploy` object from the JSON representation of a deploy
 */
export declare const deployFromJson: (json: any) => Result<Deploy, Error>;
/**
 * Adds a runtime argument to a `Deploy` object
 * @param deploy The `Deploy` object for which to add the runtime argument
 * @param name The name of the runtime argument
 * @param value The value of the runtime argument
 * @returns The original `Deploy` with the additional runtime argument
 * @remarks Will fail if the `Deploy` has already been signed
 */
export declare const addArgToDeploy: (deploy: Deploy, name: string, value: CLValue) => Deploy;
/**
 * Gets the byte-size of a deploy
 * @param deploy The `Deploy` for which to calculate the size
 * @returns The size of the `Deploy` in its serialized representation
 */
export declare const deploySizeInBytes: (deploy: Deploy) => number;
/**
 * Validate a `Deploy` by calculating and comparing its stored blake2b hash
 * @param deploy A `Deploy` to be validated
 * @returns A `Result` that collapses to a `Deploy` or an error string
 */
export declare const validateDeploy: (deploy: Deploy) => Result<Deploy, string>;
/**
 * Compares two `Uint8Array`s
 * @param a The first `Uint8Array`
 * @param b The second `Uint8Array`
 * @returns `true` if the two `Uint8Array`s match, and `false` otherwise
 */
export declare const arrayEquals: (a: Uint8Array, b: Uint8Array) => boolean;
/**
 * Serializes a `Deploy` to a `Uint8Array`
 * @param deploy The `Deploy` to be serialized
 * @returns A `Uint8Array` serialization of the provided `Deploy`
 */
export declare const deployToBytes: (deploy: Deploy) => Uint8Array;
export {};
