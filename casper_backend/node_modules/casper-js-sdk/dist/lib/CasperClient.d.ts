import { CasperServiceByJsonRPC, GetDeployResult } from '../services';
import { DeployUtil, CLPublicKey } from './index';
import { Deploy, DeployParams, ExecutableDeployItem } from './DeployUtil';
import { AsymmetricKey, SignatureAlgorithm } from './Keys';
import { CasperHDKey } from './CasperHDKey';
import { BigNumber } from '@ethersproject/bignumber';
export declare class CasperClient {
    nodeClient: CasperServiceByJsonRPC;
    /**
     * Construct a CasperClient object
     * @param nodeUrl The url of the node to be communicated with
     */
    constructor(nodeUrl: string);
    /**
     * Generate a new key pair
     * @param algo The signature algorithm of the account. The possible values are `SignatureAlgorithm.Ed25519` and SignatureAlgorithm.Secp256K1
     * @returns New key pair with the specified SignatureAlgorithm
     */
    newKeyPair(algo: SignatureAlgorithm): AsymmetricKey;
    /**
     * Load private key from file
     * @param path The path to the publicKey file
     * @param algo The signature algorithm of the account. The possible values are `SignatureAlgorithm.Ed25519` and SignatureAlgorithm.Secp256K1
     * @returns New key pair with the specified SignatureAlgorithm
     */
    loadPublicKeyFromFile(path: string, algo: SignatureAlgorithm): Uint8Array;
    /**
     * Load private key to buffer
     * @param path The path to the private key file
     * @param algo The signature algorithm of the account. Currently we support Ed25519 and Secp256K1
     * @returns Uint8Array buffer of the private key
     */
    loadPrivateKeyFromFile(path: string, algo: SignatureAlgorithm): Uint8Array;
    /**
     * Load private key file to usable keypair
     * @param path The path to the private key file
     * @param algo The signature algorithm of the account
     * @returns Usable keypair
     */
    loadKeyPairFromPrivateFile(path: string, algo: SignatureAlgorithm): AsymmetricKey;
    /**
     * Create a new hierarchical deterministic wallet, supporting bip32 protocol
     * @param seed The seed buffer for parent key
     * @returns A new bip32 compliant hierarchical deterministic wallet
     */
    newHdWallet(seed: Uint8Array): CasperHDKey;
    /**
     * Compute public key from private key
     * @param privateKey Private key buffer
     * @param algo The signature algorithm of the account. Currently we support Ed25519 and Secp256K1
     * @returns Uint8Array buffer of the public key computed from the provided private key
     */
    privateToPublicKey(privateKey: Uint8Array, algo: SignatureAlgorithm): Uint8Array;
    /**
     * Construct an unsigned Deploy object from the deploy parameters, session logic, and payment logic
     * @param deployParams Deploy parameters
     * @param session Session logic
     * @param payment Payment logic
     * @returns An unsigned Deploy object
     * @see [DeployUtil.makeDeploy](./DeployUtil.ts#L1059)
     */
    makeDeploy(deployParams: DeployParams, session: ExecutableDeployItem, payment: ExecutableDeployItem): Deploy;
    /**
     * Sign the deploy with the specified signKeyPair
     * @param deploy Unsigned Deploy object
     * @param signKeyPair the keypair used to sign the Deploy object
     * @returns A signed Deploy object
     * @see [DeployUtil.signDeploy](./DeployUtil.ts#L1087)
     */
    signDeploy(deploy: Deploy, signKeyPair: AsymmetricKey): Deploy;
    /**
     * Send deploy to network
     * @param signedDeploy Signed deploy object
     * @returns The sent Deploy's transaction hash, as a hexadecimal string
     */
    putDeploy(signedDeploy: Deploy): Promise<string>;
    /**
     * Test deploy to network
     * @param signedDeploy Signed deploy object
     */
    speculativeDeploy(signedDeploy: Deploy, blockIdentifier?: string): Promise<string>;
    /**
     * Convert the Deploy object to a JSON representation
     * @param deploy A Deploy object
     * @returns A JSON representation of the Deploy
     * @see [DeployUtil.deployToJson](./DeployUtil.ts#L1150)
     */
    deployToJson(deploy: Deploy): {
        deploy: import("typedjson").JsonTypes;
    };
    /**
     * Convert a JSON Deploy representation to a Deploy object
     * @param json A JSON respresentation of a deploy
     * @returns A Deploy object
     * @see [DeployUtil.deployToJson](./DeployUtil.ts#L1150)
     */
    deployFromJson(json: any): import("ts-results").Result<DeployUtil.Deploy, Error>;
    /**
     * Construct a Deploy consisting of a standard CSPR transfer. Fails if the Deploy is not a Transfer
     * @param deployParams The parameters of the Deploy
     * @param session Session logic
     * @param payment Payment logic
     */
    makeTransferDeploy(deployParams: DeployParams, session: ExecutableDeployItem, payment: ExecutableDeployItem): Deploy;
    /**
     * Get the CSPR balance of an account using its public key
     * @param publicKey CLPublicKey representation of an account's public key
     * @returns Promise that resolves to the balance of the account
     */
    balanceOfByPublicKey(publicKey: CLPublicKey): Promise<BigNumber>;
    /**
     * Get the CSPR balance of an account using its account hash
     * @param accountHashStr The account's account hash as a hexadecimal string
     * @returns Promise that resolves to the balance of the account
     */
    balanceOfByAccountHash(accountHashStr: string): Promise<BigNumber>;
    /**
     * Get deploy details using a deploy's transaction hash
     * @param deployHash The hexadecimal string representation of the deploy hash
     * @returns Tuple of Deploy and raw RPC response
     */
    getDeploy(deployHash: string): Promise<[Deploy, GetDeployResult]>;
    /**
     * Get the main purse uref for the specified publicKey
     * @param publicKey The public key of the account
     * @returns A Promise resolving to a hexadecimal string representation of the account's main purse uref
     */
    getAccountMainPurseUref(publicKey: CLPublicKey): Promise<string | null>;
}
